{"./":{"url":"./","title":"介绍","keywords":"","body":"Spring 实战 (第 6 版) "},"Chapter-01/Introduction.html":{"url":"Chapter-01/Introduction.html","title":"第 1 章 Spring 入门","keywords":"","body":"第 1 章 Spring 入门 "},"Chapter-01/1.1-What-is-Spring.html":{"url":"Chapter-01/1.1-What-is-Spring.html","title":"1.1 什么是 Spring？","keywords":"","body":"1.1 什么是 Spring？ "},"Chapter-01/1.2-Initializing-a-Spring-application/Introduction.html":{"url":"Chapter-01/1.2-Initializing-a-Spring-application/Introduction.html","title":"1.2 初始化 Spring 应用程序","keywords":"","body":"1.2 初始化 Spring 应用程序 "},"Chapter-01/1.2-Initializing-a-Spring-application/1.2.1-Initializing-a-Spring-project-with-Spring-Tool-Suite.html":{"url":"Chapter-01/1.2-Initializing-a-Spring-application/1.2.1-Initializing-a-Spring-project-with-Spring-Tool-Suite.html","title":"1.2.1 使用 Spring Tool Suite 初始化 Spring 项目","keywords":"","body":"1.2.1 使用 Spring Tool Suite 初始化 Spring 项目 "},"Chapter-01/1.2-Initializing-a-Spring-application/1.2.2-Examining-the-Spring-project-structure.html":{"url":"Chapter-01/1.2-Initializing-a-Spring-application/1.2.2-Examining-the-Spring-project-structure.html","title":"1.2.2 检查 Spring 项目结构","keywords":"","body":"1.2.2 检查 Spring 项目结构 "},"Chapter-01/1.3-Writing-a-Spring-application/Introduction.html":{"url":"Chapter-01/1.3-Writing-a-Spring-application/Introduction.html","title":"1.3 编写 Spring 应用程序","keywords":"","body":"1.3 编写 Spring 应用程序 "},"Chapter-01/1.3-Writing-a-Spring-application/1.3.1-Handling-web-requests.html":{"url":"Chapter-01/1.3-Writing-a-Spring-application/1.3.1-Handling-web-requests.html","title":"1.3.1 处理 web 请求","keywords":"","body":"1.3.1 处理 web 请求 "},"Chapter-01/1.3-Writing-a-Spring-application/1.3.2-Defining-the-view.html":{"url":"Chapter-01/1.3-Writing-a-Spring-application/1.3.2-Defining-the-view.html","title":"1.3.2 定义视图","keywords":"","body":"1.3.2 定义视图 "},"Chapter-01/1.3-Writing-a-Spring-application/1.3.3-Testing-the-controller.html":{"url":"Chapter-01/1.3-Writing-a-Spring-application/1.3.3-Testing-the-controller.html","title":"1.3.3 测试控制器","keywords":"","body":"1.3.3 测试控制器 "},"Chapter-01/1.3-Writing-a-Spring-application/1.3.4-Building-and-running-the-application.html":{"url":"Chapter-01/1.3-Writing-a-Spring-application/1.3.4-Building-and-running-the-application.html","title":"1.3.4 构建并运行应用程序","keywords":"","body":"1.3.4 构建并运行应用程序 "},"Chapter-01/1.3-Writing-a-Spring-application/1.3.5-Getting-to-know-Spring-Boot-DevTools.html":{"url":"Chapter-01/1.3-Writing-a-Spring-application/1.3.5-Getting-to-know-Spring-Boot-DevTools.html","title":"1.3.5 了解 Spring Boot DevTools","keywords":"","body":"1.3.5 了解 Spring Boot DevTools "},"Chapter-01/1.3-Writing-a-Spring-application/1.3.6-Let's-review.html":{"url":"Chapter-01/1.3-Writing-a-Spring-application/1.3.6-Let's-review.html","title":"1.3.6 回顾","keywords":"","body":"1.3.6 回顾 "},"Chapter-01/1.4-Surveying-the-Spring-landscape/Introduction.html":{"url":"Chapter-01/1.4-Surveying-the-Spring-landscape/Introduction.html","title":"1.4  俯瞰 Spring 风景线","keywords":"","body":"1.4 俯瞰 Spring 风景线 "},"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.1-The-core-Spring-Framework.html":{"url":"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.1-The-core-Spring-Framework.html","title":"1.4.1 Spring 核心框架","keywords":"","body":"1.4.1 Spring 核心框架 "},"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.2-Spring-Boot.html":{"url":"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.2-Spring-Boot.html","title":"1.4.2 Spring Boot","keywords":"","body":"1.4.2 Spring Boot "},"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.3-Spring-Data.html":{"url":"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.3-Spring-Data.html","title":"1.4.3 Spring Data","keywords":"","body":"1.4.3 Spring Data "},"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.4-Spring-Security.html":{"url":"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.4-Spring-Security.html","title":"1.4.4 Spring Security","keywords":"","body":"1.4.4 Spring Security "},"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.5-Spring-Integration-and-Spring-Batch.html":{"url":"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.5-Spring-Integration-and-Spring-Batch.html","title":"1.4.5 Spring Integration 和 Spring Batch","keywords":"","body":"1.4.5 Spring Integration 和 Spring Batch "},"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.6-Spring-Cloud.html":{"url":"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.6-Spring-Cloud.html","title":"1.4.6 Spring Cloud","keywords":"","body":"1.4.6 Spring Cloud "},"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.7-Spring-Native.html":{"url":"Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.7-Spring-Native.html","title":"1.4.7 Spring Native","keywords":"","body":"1.4.7 Spring Native "},"Chapter-01/1.5-Summary.html":{"url":"Chapter-01/1.5-Summary.html","title":"1.5 小结","keywords":"","body":"1.5 小结 "},"Chapter-15/Introduction.html":{"url":"Chapter-15/Introduction.html","title":"第 15 章 使用 Spring Boot Actuator","keywords":"","body":"第 15 章 使用 Spring Boot Actuator 本章内容 在 Spring Boot 项目中启用 Actuator 探索 Actuator 的 endpoint 定制 Actuator 为 Actuator 增加安全机制 您有没有猜过，一个礼物包装盒里面到底是什么礼物呢？摇一摇、掂一掂、量一下尺寸，可能对里面的东西猜个八九不离十。但是直到打开它之前，是没有办法百分百的确定的。 一个正在运行的应用程序，就像一份包装好的礼物。您可以访问它，然后根据反馈做出相对合理的猜测。但您能保证一定猜测正确吗？如果能有什么办法，能让您看到应用程序的内部：查看是如何运行的、查看它的健康状况，甚至触发一些操作以改变其运行方式，那就可以确定应用程序的实际情况了！ 在本章中，我们将探讨 Spring Boot 的 Actuator。Actuator 可以对 Spring Boot 应用程序进行监视，并提供一些度量指标。这些都是可以应用于生产环境的特性。 Actuator 的特征通过几个 endpoint 提供，这些 endpoint 可通过 HTTP 和 JMX mbean 获得。本章主要关注 HTTP endpoint，而在第 17 章讨论 JMX endpoint。 "},"Chapter-15/15.1-Introducing-Actuator/Introduction.html":{"url":"Chapter-15/15.1-Introducing-Actuator/Introduction.html","title":"15.1 介绍 Actuator","keywords":"","body":"15.1 介绍 Actuator 在机器设备中， Actuator 指驱动器，是负责控制和移动机器的机械装置。在 Spring Boot 应用程序中，Spring Boot Actuator 扮演同样的角色，使我们能够看到正在运行的应用程序的内部。在某种程度上，控制应用程序的行为。 使用 Actuator 公开的 endpoint，我们可以获取正在运行的 Spring Boot 应用程序的一些情况： 应用程序环境中有哪些配置属性可用？ 应用程序中各种包的日志记录级别是什么？ 应用程序现在消耗了多少内存？ 给定的 HTTP endpoint 被请求了多少次？ 应用程序及其协作的其他服务的健康状况如何？ 要在 Spring Boot 应用程序中启用 Actuator，只需添加 Actuator 的依赖。在 Spring Boot 应用程序 pom.xml 文件中，添加如下部分： org.springframework.boot spring-boot-starter-actuator 一旦 Actuator 依赖添加到了项目构建中，应用程序就有了几个现成的 endpoint，包括表 16.1 中所描述的这些。 表 15.1：窥视 Spring Boot 应用程序内部，并操纵其运行状态的 Actuator endpoint HTTP 方法 路径 描述 是否默认启用 GET /auditevents 生成已触发的任何审核事件的报告。 否 GET /beans 描述 Spring 应用程序上下文中的所有 bean。 否 GET /conditions 对于在应用程序上下文中创建的 bean，自动配置条件校验通过或失败的报告。 否 GET /configprops 描述所有配置属性以及当前值。 否 GET, POST, DELETE /env 生成 Spring 应用程序可用的所有属性源及其属性的报告。 否 GET /env/{toMatch} 描述单个环境属性的值。 否 GET /health 返回应用程序的聚合运行状况和（可能）外部相关应用程序的运行状况。 是 GET /heapdump 下载堆转储信息。 否 GET /httptrace 生成最近 100 个请求的跟踪记录。 否 GET /info 返回开发人员自定义的应用程序信息。 是 GET /loggers 生成应用程序中包的列表，及其配置的有效日志级别。 否 GET，POST /loggers/{name} 返回某个 logger 的有效日志记录级别，并可以通过 POST 请求设置日志级别。 否 GET /mappings 生成关于所有 HTTP 映射及其相应处理方法的报告。 否 GET /metrics 返回所有度量指标类别的列表。 否 GET /metrics/{name} 返回某度量的多维值的集合。 否 GET /scheduledtasks 列出所有计划任务 否。 GET /threaddump 返回所有应用程序线程的报告。 否 除了基于 HTTP 的 endpoint，表 15.1 中的所有 Actuator 的 endpoint，除 /heapdump 以外，同时暴露为 JMX MBean。我们将在第 17 章讨论 JMX 的 Actuator。 "},"Chapter-15/15.1-Introducing-Actuator/15.1.1-Configuring-Actuator's-base-path.html":{"url":"Chapter-15/15.1-Introducing-Actuator/15.1.1-Configuring-Actuator's-base-path.html","title":"15.1.1 配置 Actuator 基本路径","keywords":"","body":"15.1.1 配置 Actuator 基本路径 默认情况下，在表 15.1 中显示的所有路径都以 /exactor 为前缀。这意味着，如果您希望从 Actuator 获取应用的健康状况信息，您可以对路径 /actuator/health 发送 GET 请求来获得。 您可以通过设置 management.endpoint.web.base-path 属性来更改前缀路径。例如，如果您希望将前缀路径更改为 /management，您可以进行如下设置： management: endpoints: web: base-path: /management 上述的属性设置之后，您就可以对路径 /management/health 发出 GET 请求，来获得应用程序的健康状况信息。 无论您是否更改 Actuator 基本路径，为了简洁起见，本章中用到的 Actuator 将会省略基本路径。例如，当提到 /health 端点时，实际是 /{base path}/health 端点。更准确地说，如果基本路径没有更改，则应该为 /exactor/health 端点。 "},"Chapter-15/15.1-Introducing-Actuator/15.1.2-Enabling-and-disabling-Actuator-endpoints.html":{"url":"Chapter-15/15.1-Introducing-Actuator/15.1.2-Enabling-and-disabling-Actuator-endpoints.html","title":"15.1.2 启用和禁用 Actuator 端点","keywords":"","body":"15.1.2 启用和禁用 Actuator 端点 您可能已经注意到，默认情况下只启用了 /health 端点。由于大多数 Actuator 携带有敏感信息，所以应予以保护。Actuator 自身并没有提供安全措施，但您可以使用 Spring Security 来保护 Actuator。对于禁用的端点，您可以手动将其打开。 有两个配置属性： management.endpoints.web.exposure.include 和 management.endpoints.web.exposure.exclude， 可用于控制端点的启用和关闭。使用 management.endpoints.web.exposure.include，您可以指定要启用的端点。例如，如果您只想公开 /health、/info、/beans 和 /conditions，可以使用以下配置： management: endpoints: web: exposure: include: health,info,beans,conditions management.endpoints.web.exposure.include 属性也可以使用星号（*）通配符，将所有 Actuator 端点都启用： management: endpoints: web: exposure: include: '*' 如果要启用除少数端点以外的所有端点，通常更方便的做法是：使用通配符将它们全部包含在内，然后显式排除一些。例如，启用所有但除了 /threaddump 和 /heapdump 之外的 Actuator 端点。您可以像下面这样设置 management.endpoints.web.exposure.include 和 management.endpoints.web.exposure.exclude 属性： management: endpoints: web: exposure: include: '*' exclude: threaddump,heapdump 如果您决定不仅仅启用 /health 和 /info，那么配置 Spring Security 以限制对其他端点的任意访问是个好主意。我们将在第 15.4 节讨论如何保护 Actuator 端点。现在，让我们看看如何访问这些已经启用的 HTTP 端点。 "},"Chapter-15/15.2-Consuming-Actuator-endpoints/Introduction.html":{"url":"Chapter-15/15.2-Consuming-Actuator-endpoints/Introduction.html","title":"15.2 使用 Actuator 端点","keywords":"","body":"15.2 使用 Actuator 端点 Actuator 可以通过表 15.1 中列出的 HTTP 端点，提供一个有关正在运行的应用程序的，有趣和有用的名副其实的宝库。 作为 HTTP 端点，它们可以像任何 REST API 一样使用，使用您熟悉的任何 HTTP 客户端，包括 Spring 的 RestTemplate 和 WebClient，来自基于浏览器的 JavaScript 应用程序，或者简单地使用 curl 命令行客户端。 为了探索 Actuator 端点，您将在本章中使用 curl 命令行客户端。 在第 16 章中，我将向您介绍 Spring Boot Admin，它在应用程序的 Actuator 端点之上构建出了一个用户友好的 Web 应用程序。 为了解 Actuator 都提供了哪些端点，可以对 Actuator 基本路径发送 GET 请求，这将返回所有端点的 HATEOAS 链接。 使用 curl 向 /actuator 发出请求，您可能会得到类似这样的响应（为了节省篇幅而进行了删节）： $ curl localhost:8081/actuator { \"_links\": { \"self\": { \"href\": \"http://localhost:8081/actuator\", \"templated\": false }, \"auditevents\": { \"href\": \"http://localhost:8081/actuator/auditevents\", \"templated\": false }, \"beans\": { \"href\": \"http://localhost:8081/actuator/beans\", \"templated\": false }, \"health\": { \"href\": \"http://localhost:8081/actuator/health\", \"templated\": false } }, ... } 因为不同的库可能会贡献自己额外的 Actuator 端点，并且因为某些端点可能不会被暴露，所以实际结果可能因应用程序而异。 不论差异如何，从 Actuator 的基本路径返回的这些链接，都明确展示了 Actuator 所提供的端点。让我们开始探索 Actuator, 从提供应用程序的基本信息的两个端点 /health 和 /info 开始。 "},"Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.1-Fetching-essential-application-information.html":{"url":"Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.1-Fetching-essential-application-information.html","title":"15.2.1 获取重要的应用程序信息","keywords":"","body":"15.2.1 获取重要的应用程序信息 在一次典型的看医生开始时，我们通常会被问到两个非常基本的问题：你是谁，你感觉如何？尽管医生或护士选择的词可能不同，但他们最终目标是想了解一些基本情况：关于他们正在治疗的人，以及您为什么要见他们。 这些相同的基本问题是 Actuator 的 /info 和 /health 端点为 Spring Boot 应用程序回答的。 /info 端点告诉您有关应用程序的一些信息，/health 端点告诉您应用程序的健康状况。 询问有关应用程序的信息 要了解有关正在运行的 Spring Boot 应用程序的一些信息，您可以询问 /info 端点。 但是，默认情况下， /info 端点的信息量并不大。 当您使用 curl 发出请求时，您可能会看到以下内容： $ curl localhost:8081/actuator/info {} 虽然 /info 端点似乎不是很有用，但最好将其视为一个干净的画布，您可以在其上绘制您想要呈现的任何信息。 有多种方法可以提供 /info 端点返回所需的信息，最直接的方法是创建一个或多个配置属性，其中属性名称以 info. 为前缀。例如，假设您希望来自 /info 端点以包含支持联系信息，包括电子邮件地址和电话号码。 为此，您可以在 application.yml 文件中配置以下属性： info: contact: email: support@tacocloud.com phone: 822-625-6831 info.contact.email 和 info.contact.phone 属性可能对于 Spring Boot，或应用程序上下文中的任何 bean 都没有任何特殊意义。 然而，由于它以 info. 为前缀，/info 端点现在将在其响应中回显属性的值： { \"contact\": { \"email\": \"support@tacocloud.com\", \"phone\": \"822-625-6831\" } } 在第 15.3.1 节中，我们将了解一些其他方法来使 /info 端点返回有关应用程序的更多有用信息。 检查应用程序健康状态 向 /health 端点发送 HTTP GET 请求会产生一个简单的 JSON 响应，其中包含应用程序的健康状态。 例如，以下是您在使用 curl 获取 /health 端点时可能会看到的内容： $ curl localhost:8080/actuator/health {\"status\":\"UP\"} 您可能想知道，一个只能报告应用程序已启动的端点有多大用处？如果应用程序关闭，它会报告什么？ 实际情况是，此处显示的状态是一个或多个健康指标的聚合状态。健康指标报告应用程序与之交互的外部系统的健康状况，例如数据库、消息代理，甚至 Eureka 和 Config Server 等 Spring Cloud 组件。每个指标的健康状态可以是以下之一： UP - 外部系统已启动并可访问。 DOWN - 外部系统已关闭或无法访问。 UNKNOWN - 外部系统的状态尚不清楚。 OUT_OF_SERVICE - 外部系统可访问，但当前不可用。 然后将所有健康指标的健康状态，聚合到应用程序的整体健康状态中，应用以下规则： 如果所有健康指标都为 UP，则应用程序健康状态为 UP。 如果一个或多个健康指标为 DOWN，则应用程序健康状态为 DOWN。 如果一个或多个健康指标为 OUT_OF_SERVICE，则应用健康状态为 OUT_OF_SERVICE。 UNKNOWN 健康状况将被忽略，并且不会被纳入应用程序的总体健康状况。 默认情况下，仅返回聚合状态以响应对 /health 的请求。但是，您可以配置 management.endpoint.health.show-details 属性以显示所有健康指标的完整详细信息： management: endpoint: health: show-details: always management.endpoint.health.show-details 属性默认为 never，但也可以设置为 always 始终显示所有健康指标的完整详细信息，或 when-authorized 仅在请求客户端时显示完整详细信息完全授权。 现在，当您向 /health 端点发出 GET 请求时，您将获得完整的健康指标详细信息。 以下是与 Mongo 文档数据库集成的服务的示例： { \"status\": \"UP\", \"details\": { \"mongo\": { \"status\": \"UP\", \"details\": { \"version\": \"3.2.2\" } }, \"diskSpace\": { \"status\": \"UP\", \"details\": { \"total\": 499963170816, \"free\": 177284784128, \"threshold\": 10485760 } } } } 无论任何其他外部依赖项如何，所有应用程序都将具有名为 diskSpace 的文件系统的运行状况指示器。 diskSpace 运行状况指示器指示文件系统的运行状况（希望是 UP），这取决于剩余的可用空间量。 如果可用磁盘空间低于阈值，它将报告 DOWN 状态。 在前面的示例中，还有一个 mongo 健康指示器，用于报告 Mongo 数据库的状态。 显示的详细信息包括 Mongo 数据库版本。 自动配置确保只有与应用程序相关的健康指标，才会出现在来自 /health 端点的响应中。 除了 mongo 和 diskSpace 健康指标，Spring Boot 还为其他几个外部数据库和系统提供健康指标，包括： Cassandra Config Server Couchbase Eureka Hystrix JDBC data sources Elasticsearch InfluxDB JMS message brokers LDAP Email servers Neo4j Rabbit message brokers Redis Solr 此外，第三方库可能会贡献自己的健康指标。 我们将在 15.3.2 节中了解如何编写自定义健康指标。 如您所见，/health 和 /info 端点提供有关正在运行的应用程序的一般信息。 同时，还有其他 Actuator 端点可以深入了解应用程序配置。 让我们看看 Actuator 如何显示应用程序的配置信息。 "},"Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.2-Viewing-configuration-details.html":{"url":"Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.2-Viewing-configuration-details.html","title":"15.2.2 查看配置详细信息","keywords":"","body":"15.2.2 查看配置详细信息 除了获取有关应用程序的一般信息之外，了解应用程序的配置信息也很有用。应用程序上下文中有哪些 bean？哪些自动配置条件通过或失败？应用程序可以使用哪些环境属性？HTTP 请求如何映射到控制器？一个或多个包或类设置为怎样的日志级别？ 这些问题由 Actuator 的 /beans、/conditions、/env、/configprops、/mappings 和 /loggers 端点回答。 在某些情况下，例如 /env 和 /loggers，您甚至可以动态调整正在运行的应用程序的配置。从 /beans 端点开始，我们将查看每一个端点，以深入了解正在运行的应用程序的配置。 获取 Bean Wiring 报告 探索 Spring 应用程序上下文最重要的端点是 /beans 端点。此端点返回一个 JSON 文档，描述应用程序上下文中的每个 bean、它的 Java 类型以及它注入的任何其他 bean。 对 /beans 的 GET 请求所得到的完整响应信息非常多，可以轻松地填满本章。作为完整响应的替代，让我们考虑以下片段，它专注于单个 bean 条目： { \"contexts\": { \"application-1\": { \"beans\": { ... \"ingredientsController\": { \"aliases\": [], \"scope\": \"singleton\", \"type\": \"tacos.ingredients.IngredientsController\", \"resource\": \"file [/Users/habuma/Documents/Workspaces/ TacoCloud/ingredient-service/target/classes/tacos/ingredients/ IngredientsController.class]\", \"dependencies\": [ \"ingredientRepository\" ] }, ... }, \"parentId\": null } } } 响应的根是 contexts 元素，它包含应用程序中每个 Spring 应用程序上下文的一个子元素。在每个应用程序上下文中都有一个 beans 元素，其中包含应用程序上下文中所有 bean 的详细信息。 在前面的示例中，显示的 bean 是名称为 ingredientsController 的 bean。您可以看到它没有别名，范围为单例，并且类型为 tacos.ingredients.IngredientsController。此外，资源属性给出了定义 bean 的类文件的路径。并且 dependencies 属性列出了注入给定 bean 的所有其他 bean。 在这种情况下，ingredientsController bean 被注入了一个名称为 ingredientRepository 的 bean。 解释自动配置 如您所见，自动配置是 Spring Boot 提供的最强大的功能之一。但是，有时您可能想知道为什么会自动配置某些内容。或者您可能期望某些东西被自动配置，想知道它为什么没有被自动配置。在这种情况下，您可以向 /conditions 发出 GET 请求，以了解自动配置的情况。 /conditions 返回的自动配置报告分为三部分：positiveMatches（条件配置通过）、negativeMatches（条件配置失败）和 unconditionalClasses（无条件类）。以下是 /conditions 请求的响应的片段，示例显示了每个部分： { \"contexts\": { \"application-1\": { \"positiveMatches\": { ... \"MongoDataAutoConfiguration#mongoTemplate\": [ { \"condition\": \"OnBeanCondition\", \"message\": \"@ConditionalOnMissingBean (types :org.springframework.data.mongodb.core.MongoTemplate; SearchStrategy: all) did not find any beans\" } ], ... }, \"negativeMatches\": { ... \"DispatcherServletAutoConfiguration\": { \"notMatched\": [ { \"condition\": \"OnClassCondition\", \"message\": \"@ConditionalOnClass did not find required class 'org.springframework.web.servlet. DispatcherServlet'\" } ], \"matched\": [] }, ... }, \"unconditionalClasses\": [ ... \"org.springframework.boot.autoconfigure.context. ConfigurationPropertiesAutoConfiguration\", ... ] } } } 在 positiveMatches 部分，您会看到 MongoTemplate bean 是由自动配置配置的，且因为它不存在。导致这种情况的自动配置是因为有 @ConditionalOnMissingBean 注释，如果尚未显式配置要配置的 bean，则它会传递要配置的 bean。在这种情况下，由于没有找到 MongoTemplate 类型的 bean，因此自动配置介入并配置了一个。 在 negativeMatches 下，Spring Boot 自动配置考虑配置一个 DispatcherServlet。但是 @ConditionalOnClass 条件注解失败了，因为找不到 DispatcherServlet。 最后，如 unconditionalClasses 部分所示，配置了 ConfigurationPropertiesAutoConfiguration bean。配置属性是 Spring Boot 运行的基础，因此任何与配置属性相关的配置，都应该在没有任何条件的情况下自动配置。 检查环境和配置属性 除了了解您的应用程序 bean 如何连接在一起之外，您可能还对了解哪些环境属性可用，以及哪些配置属性注入了 bean 中感兴趣。 当您向 /env 端点发出 GET 请求时，您将收到一个相当长的，来自 Spring 应用程序正在运行的，所有属性来源的属性列表。这包括来自环境变量的属性、JVM 系统属性、application.properties 和 application.yml 文件，甚至 Spring Cloud Config Server（如果应用程序是 Config Server 的客户端）。 下面的清单显示了，您可能从 /env 端点获得的响应数据的一个大大简化的示例，让您对它提供的信息有所了解。 清单 15.1 来自 /env 端点的数据 $ curl localhost:8081/actuator/env { \"activeProfiles\": [ \"development\" ], \"propertySources\": [ ... { \"name\": \"systemEnvironment\", \"properties\": { \"PATH\": { \"value\": \"/usr/bin:/bin:/usr/sbin:/sbin\", \"origin\": \"System Environment Property \\\"PATH\\\"\" }, ... \"HOME\": { \"value\": \"/Users/habuma\", \"origin\": \"System Environment Property \\\"HOME\\\"\" } } }, { \"name\": \"applicationConfig: [classpath:/application.yml]\", \"properties\": { \"spring.application.name\": { \"value\": \"ingredient-service\", \"origin\": \"class path resource [application.yml]:3:11\" }, \"server.port\": { \"value\": 8081, \"origin\": \"class path resource [application.yml]:9:9\" }, ... } }, ... ] } 尽管 /env 的完整响应提供了更多信息，但清单 15.1 中包含了那些需要关注的元素。首先，请注意响应顶部是一个名为 activeProfiles 的字段。现在的配置表明 development 配置文件处于活动状态。 如果任何其他配置文件处于活动状态，也将列出这些配置文件。 接下来，propertySources 字段是一个数组，其中包含 Spring 应用程序环境中每个属性源的条目。在清单 15.1 中，只显示了 systemEnvironment 和引用 application.yml 文件的 applicationConfig 属性源。 在每个属性源中，列出了该源提供的所有属性，并与其值配对。在 application.yml 属性源的情况下，每个属性的 origin 字段准确说明属性设置的位置，包括在 application.yml 中的行和列。 当该属性的名称作为路径的第二个元素给出时，/env 端点还可用于获取特定属性。例如，要检查 server.port 属性，请提交对 /env/server.port 的 GET 请求，如下所示： $ curl localhost:8081/actuator/env/server.port { \"property\": { \"source\": \"systemEnvironment\", \"value\": \"8081\" }, \"activeProfiles\": [ \"development\" ], \"propertySources\": [ { \"name\": \"server.ports\" }, { \"name\": \"mongo.ports\" }, { \"name\": \"systemProperties\" }, { \"name\": \"systemEnvironment\", \"property\": { \"value\": \"8081\", \"origin\": \"System Environment Property \\\"SERVER_PORT\\\"\" } }, { \"name\": \"random\" }, { \"name\": \"applicationConfig: [classpath:/application.yml]\", \"property\": { \"value\": 0, \"origin\": \"class path resource [application.yml]:9:9\" } }, { \"name\": \"springCloudClientHostInfo\" }, { \"name\": \"refresh\" }, { \"name\": \"defaultProperties\" }, { \"name\": \"Management Server\" } ] } 如您所见，所有属性源仍被表示，但只有那些设置了指定属性的源才会包含附加信息。在这种情况下，系统环境属性源和 application.yml 属性源都具有 server.port 属性的值。因为 systemEnvironment 属性源优先于它下面列出的任何属性源，所以它的值 8081 胜出。获胜值反映在属性字段下方的顶部附近。 /env 端点不仅可以用于读取属性值。通过向 /env 端点提交 POST 请求以及带有名称和值字段的 JSON 数据，您还可以在正在运行的应用程序中设置属性。例如，要将名为 tacocloud.discount.code 的属性设置为 TACOS1234，您可以使用 curl 在命令行提交 POST 请求，如下所示： $ curl localhost:8081/actuator/env \\ -d'{\"name\":\"tacocloud.discount.code\",\"value\":\"TACOS1234\"}' \\ -H \"Content-type: application/json\" {\"tacocloud.discount.code\":\"TACOS1234\"} 提交属性后，新设置的属性及其值将在响应中返回。稍后，如果您决定不再需要该属性，您可以向 /env 端点提交 DELETE 请求，以删除通过该端点创建的所有属性： $ curl localhost:8081/actuator/env -X DELETE {\"tacocloud.discount.code\":\"TACOS1234\"} 与通过 Actuator 的 API 设置属性一样重要，要注意，使用 /env 端点的 POST 请求设置的任何属性，仅适用于接收请求的应用程序实例，是临时的，并且会在应用程序重新启动时丢失. 浏览 HTTP 请求映射 尽管 Spring MVC（和 Spring WebFlux 的）编程模型，通过简单地使用请求映射注释，对方法进行注释来轻松处理 HTTP 请求，但有时很难全面了解，应用程序可以处理的所有类型的 HTTP 请求，以及处理这些请求的组件类型。 Actuator 的 /mappings 端点提供了应用程序中每个 HTTP 请求处理程序的一站式视图，无论是来自 Spring MVC 控制器还是 Actuator 自己的端点之一。要获取 Spring Boot 应用程序中所有端点的完整列表，请向 /mappings 端点发出 GET 请求，您可能会收到类似于下面显示的简化响应的内容。 清单 15.2 如 /mappings 端点所示的 HTTP 请求映射 $ curl localhost:8081/actuator/mappings | jq { \"contexts\": { \"application-1\": { \"mappings\": { \"dispatcherHandlers\": { \"webHandler\": [ ... { \"predicate\": \"{[/ingredients],methods=[GET]}\", \"handler\": \"public reactor.core.publisher.Flux tacos.ingredients.IngredientsController.allIngredients()\", \"details\": { \"handlerMethod\": { \"className\": \"tacos.ingredients.IngredientsController\", \"name\": \"allIngredients\", \"descriptor\": \"()Lreactor/core/publisher/Flux;\" }, \"handlerFunction\": null, \"requestMappingConditions\": { \"consumes\": [], \"headers\": [], \"methods\": [ \"GET\" ], \"params\": [], \"patterns\": [ \"/ingredients\" ], \"produces\": [] } } }, ... ] } }, \"parentId\": \"application-1\" }, \"bootstrap\": { \"mappings\": { \"dispatcherHandlers\": {} }, \"parentId\": null } } } 在这里，来自命令 curl 的响应通过管道传输到一个名为 jq 的解析器中，以更美观易读的方式打印 JSON 数据。为简洁起见，此响应已被删节以仅显示单个请求处理程序。具体来说，它表明对 /ingredients 的 GET 请求将由 IngredientsController 的 allIngredients() 方法处理。 管理日志级别 日志记录对任何应用程序来说都是非常重要的功能。日志记录可以提供一种审计手段，以及一种粗略的调试手段。 设置日志记录级别是需要进行反复权衡的行为。如果日志级别设置得低，日志中可能会出现过多的噪音，可能很难找到有用的信息。另一方面，如果您将日志记录级别设置得太高，则日志对于了解应用程序正在执行的操作可能没有多大价值。 日志级别通常应用在包级别上。如果您想知道正在运行的 Spring Boot 应用程序中设置了哪些日志记录级别，您可以向 /loggers 端点发出 GET 请求。以下 JSON 显示了对 /loggers 的响应的摘录： { \"levels\": [ \"OFF\", \"ERROR\", \"WARN\", \"INFO\", \"DEBUG\", \"TRACE\" ], \"loggers\": { \"ROOT\": { \"configuredLevel\": \"INFO\", \"effectiveLevel\": \"INFO\" }, ... \"org.springframework.web\": { \"configuredLevel\": null, \"effectiveLevel\": \"INFO\" }, ... \"tacos\": { \"configuredLevel\": null, \"effectiveLevel\": \"INFO\" }, \"tacos.ingredients\": { \"configuredLevel\": null, \"effectiveLevel\": \"INFO\" }, \"tacos.ingredients.IngredientServiceApplication\": { \"configuredLevel\": null, \"effectiveLevel\": \"INFO\" } } } 响应数据以所有有效日志记录级别的列表开始。之后，loggers 元素会列出应用程序中每个包的日志记录级别的详细信息。 configureLevel 属性显示已显式配置的日志记录级别（如果尚未显式配置，则为 null）。 EffectiveLevel 属性给出了有效的日志级别，它可能是从父包或根记录器继承的。 此示例仅显示了根记录器和四个包的日志记录级别，完整的响应会包括应用程序中每个包的日志记录级别条目，包含所有使用到的库中的包。如果您希望查看特定包，您可以将包名称指定为请求路径中的一部分。 例如，如果您只想知道为 tacocloud.ingredients 设置了哪些日志记录级别。您可以向 /loggers/tacos.ingredients 发出请求： { \"configuredLevel\": null, \"effectiveLevel\": \"INFO\" } 除了返回应用程序包的日志级别外，/loggers 端点还允许您通过发出 POST 请求来更改配置的日志级别。例如，假设您要将 tacocloud.ingredients 包的日志记录级别设置为 DEBUG。用以下 curl 命令将实现这一点： $ curl localhost:8081/actuator/loggers/tacos/ingredients \\ -d'{\"configuredLevel\":\"DEBUG\"}' \\ -H\"Content-type: application/json\" 现在日志级别已更改，您可以向 /loggers/tacos/ingredients 发出 GET 请求以查看更改： { \"configuredLevel\": \"DEBUG\", \"effectiveLevel\": \"DEBUG\" } 请注意，configuredLevel 以前为 null，现在是 DEBUG。这种变化也传递到了 effectiveLevel。但最重要的是，如果该包中的任何代码在调试级别记录任何内容，日志文件将包含该调试级别信息。 "},"Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.3-Viewing-application-activity.html":{"url":"Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.3-Viewing-application-activity.html","title":"15.2.3 查看应用程序活动","keywords":"","body":"15.2.3 查看应用程序活动 关注应用程序中的活动是非常有用的。这些活动包括应用程序正在处理的各种 HTTP 请求，以及应用程序中的所有线程等等。为此，Actuator 提供了 /httptrace、/threaddump 和 /heapdump 端点。 /heapdump 端点可能是 Actuator 最难详细描述的端点。简单来说，它下载一个 gzip 压缩的 HPROF 堆转储文件，以便对内存或线程问题进行分析跟踪。因篇幅原因，且堆转储的使用是一个相当高级的特性，所以仅在这里提一下 /heapdump 端点。 跟踪 HTTP 活动 /httptrace 端点报告应用处理的最近 100 个请求。详细信息包括请求的方法和路径、时间戳、请求和响应的头信息，以及处理请求的耗时。 下面的 JSON 片段显示了 /httptrace 端点的返回： { \"traces\": [ { \"timestamp\": \"2020-06-03T23:41:24.494Z\", \"principal\": null, \"session\": null, \"request\": { \"method\": \"GET\", \"uri\": \"http://localhost:8081/ingredients\", \"headers\": { \"Host\": [\"localhost:8081\"], \"User-Agent\": [\"curl/7.54.0\"], \"Accept\": [\"*/*\"] }, \"remoteAddress\": null }, \"response\": { \"status\": 200, \"headers\": { \"Content-Type\": [\"application/json;charset=UTF-8\"] } }, \"timeTaken\": 4 }, ... ] } 这些信息可能对调试很有用，但更有趣的是，随着时间的推移跟踪这些数据，可以深入了解应用程序运行状况。可以了解在给定的时间段内，应用的繁忙程度，或根据响应状态的值，统计有多少成功的请求和失败的请求。在第 16 章中，您将看到 Spring Boot Admin 如何捕获这些信息，并且将这些 HTTP 跟踪信息可视化到一个运行图中。 监视线程 除了对 HTTP 请求进行跟踪之外，要确定应用程序的运行情况，监视线程活动状态也非常有用的。/threaddump 端点生成一个当前线程活动的快照。下面是 /threaddump 响应数据片段，可以了解此端点都提供了哪些信息： { \"threadName\": \"reactor-http-nio-8\", \"threadId\": 338, \"blockedTime\": -1, \"blockedCount\": 0, \"waitedTime\": -1, \"waitedCount\": 0, \"lockName\": null, \"lockOwnerId\": -1, \"lockOwnerName\": null, \"inNative\": true, \"suspended\": false, \"threadState\": \"RUNNABLE\", \"stackTrace\": [ { \"methodName\": \"kevent0\", \"fileName\": \"KQueueArrayWrapper.java\", \"lineNumber\": -2, \"className\": \"sun.nio.ch.KQueueArrayWrapper\", \"nativeMethod\": true }, { \"methodName\": \"poll\", \"fileName\": \"KQueueArrayWrapper.java\", \"lineNumber\": 198, \"className\": \"sun.nio.ch.KQueueArrayWrapper\", \"nativeMethod\": false }, ... ], \"lockedMonitors\": [ { \"className\": \"io.netty.channel.nio.SelectedSelectionKeySet\", \"identityHashCode\": 1039768944, \"lockedStackDepth\": 3, \"lockedStackFrame\": { \"methodName\": \"lockAndDoSelect\", \"fileName\": \"SelectorImpl.java\", \"lineNumber\": 86, \"className\": \"sun.nio.ch.SelectorImpl\", \"nativeMethod\": false } }, ... ], \"lockedSynchronizers\": [], \"lockInfo\": null } 完整的线程转储报告，包括正在运行的应用程序中的每个线程。为了节省篇幅，这里的线程转储信息只显示了单个线程的一个简化条目。您可以看到，它包括线程有关的阻塞和锁定状态的详细信息，以及其他一些细节。还有一个堆栈跟踪，可以提供一些线程在代码的哪个区域所花费时间的信息。 因为 /threaddump 端点只会把请求时的线程快照信息取出来，很难全面了解线程的行为是如何随着时间的推移变化的。在第 16 章中，您将看到 Spring Boot Admin 如何实时监视 /threaddump 端点。 "},"Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.4-Tapping-runtime-metrics.html":{"url":"Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.4-Tapping-runtime-metrics.html","title":"15.2.4 利用运行时指标","keywords":"","body":"15.2.4 利用运行时指标 /metrics 端点能够报告正在运行应用程序的多项指标，包括有关内存、处理器、垃圾收集以及 HTTP 请求的相关指标。Actuator 提供了二十多种开箱即用的度量指标类别。向 /metrics 发出 GET 请求，返回的度量指标列表示例如下： $ curl localhost:8081/actuator/metrics | jq { \"names\": [ \"jvm.memory.max\", \"process.files.max\", \"jvm.gc.memory.promoted\", \"http.server.requests\", \"system.load.average.1m\", \"jvm.memory.used\", \"jvm.gc.max.data.size\", \"jvm.memory.committed\", \"system.cpu.count\", \"logback.events\", \"jvm.buffer.memory.used\", \"jvm.threads.daemon\", \"system.cpu.usage\", \"jvm.gc.memory.allocated\", \"jvm.threads.live\", \"jvm.threads.peak\", \"process.uptime\", \"process.cpu.usage\", \"jvm.classes.loaded\", \"jvm.gc.pause\", \"jvm.classes.unloaded\", \"jvm.gc.live.data.size\", \"process.files.open\", \"jvm.buffer.count\", \"jvm.buffer.total.capacity\", \"process.start.time\" ] } 由于涉及的指标太多，不可能在本文中全部讨论。作为如何使用 /metrics 端点的示例，我们仅讨论 http.server.requests 指标。 如果您不是简单地请求 /metrics，而是请求 /metrics/{METRICS CATEGORY}，您将收到关于该指标的更多详细信息。以 http.server.requests 为例，GET 请求 /metrics/http.server.requests 的返回的数据如下所示： $ curl localhost:8081/actuator/metrics/http.server.requests { \"name\": \"http.server.requests\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 2103 }, { \"statistic\": \"TOTAL_TIME\", \"value\": 18.086334315 }, { \"statistic\": \"MAX\", \"value\": 0.028926313 } ], \"availableTags\": [ { \"tag\": \"exception\", \"values\": [ \"ResponseStatusException\", \"IllegalArgumentException\", \"none\" ] }, { \"tag\": \"method\", \"values\": [ \"GET\" ] }, { \"tag\": \"uri\", \"values\": [ \"/actuator/metrics/{requiredMetricName}\", \"/actuator/health\", \"/actuator/info\", \"/ingredients\", \"/actuator/metrics\", \"/**\" ] }, { \"tag\": \"status\", \"values\": [ \"404\", \"500\", \"200\" ] } ] } 该响应最重要的部分是 measurements 部分，该部分包括请求类别的所有度量。在本例中，它报告已收到 2103 个 HTTP 请求。处理这些请求的总时间为 18.086334315 秒，处理其中某个请求所花费的最大时间为 0.028926313 秒。 查看这些通用指标很有趣，您还可以使用 availableTags 下列出的标记，进一步缩小结果范围。例如，您知道已经有 2103 个请求，但还不知道分别有多少个请求导致了 HTTP 200、HTTP 404、HTTP 500。使用状态标记，您可以获取导致 HTTP 404 状态的所有请求的指标，如下所示： $ curl localhost:8081/actuator/metrics/http.server.requests?tag=status:404 { \"name\": \"http.server.requests\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 31 }, { \"statistic\": \"TOTAL_TIME\", \"value\": 0.522061212 }, { \"statistic\": \"MAX\", \"value\": 0 } ], \"availableTags\": [ { \"tag\": \"exception\", \"values\": [ \"ResponseStatusException\", \"none\" ] }, { \"tag\": \"method\", \"values\": [ \"GET\" ] }, { \"tag\": \"uri\", \"values\": [ \"/actuator/metrics/{requiredMetricName}\", \"/**\" ] } ] } 通过使用 tag 属性指定标记名称和值，您现在可以看到针对导致 HTTP 404 响应的请求度量。返回数据表明有 31 个请求导致 404，服务时间为 0.522061212 秒。此外，很明显，一些失败的请求是对 /actuator/metrics/{requiredMetricsName} 的 GET 请求（尽管不清楚{requiredMetricsName} 路径变量解析成了什么值）。还有一些是另一个路径，由 /** 通配符路径匹配处理了。 如果您想知道这些 HTTP 404 响应中有多少响应是对 /** 路径的调用？可进一步过滤，只需在请求中增加 tag，像这样： % curl \"localhost:8081/actuator/metrics/http.server.requests?tag=status:404&tag=uri:/**\" { \"name\": \"http.server.requests\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 30 }, { \"statistic\": \"TOTAL_TIME\", \"value\": 0.519791548 }, { \"statistic\": \"MAX\", \"value\": 0 } ], \"availableTags\": [ { \"tag\": \"exception\", \"values\": [ \"ResponseStatusException\" ] }, { \"tag\": \"method\", \"values\": [ \"GET\" ] } ] } 现在您可以看到，有 30 个请求与 /** 匹配，且导致了 HTTP 404 响应。处理这些响应总共花费了 0.519791548 秒。 您还将注意到，当您细化请求时，可用的标记会越少。提供的可用标记仅与显示的指标捕获的请求相匹配。在这种情况下，exception 和 method 标记都只有一个值；很明显，所有 30 个请求都是 GET 请求，都由于 ResponseStatusException 异常导致了状态 404。 浏览 /metrics 端点可能是一项棘手的工作，但只要稍加练习，要获得您需要的数据并非不可能。在第 16 章中，您将看到如何通过 Spring Boot Admin 来使获取 /metrics 端点的数据变得更加容易。 尽管 Actuator 端点提供的信息，有助于了解 Spring Boot 应用程序的内部运行情况，但它们并不适合人工使用。作为 REST 端点，它们旨在供其他应用程序使用，可能是 UI。考虑到这一点，让我们看看如何将 Actuator 信息，展示在一个用户友好的 web 应用程序中。 "},"Chapter-15/15.3-Customizing-Actuator/Introduction.html":{"url":"Chapter-15/15.3-Customizing-Actuator/Introduction.html","title":"15.3 自定义 Actuator","keywords":"","body":"15.3 自定义 Actuator Actuator 的最大特点之一是可定制，以满足特定应用程序的需求。一些端点本身允许定制，同时，Actuator 本身允许您创建自定义端点。 让我们看一些定制 Actuator 的方法，首先是添加信息到 /info 端点。 "},"Chapter-15/15.3-Customizing-Actuator/15.3.1-Contributing-information-to-the-info-endpoint.html":{"url":"Chapter-15/15.3-Customizing-Actuator/15.3.1-Contributing-information-to-the-info-endpoint.html","title":"15.3.1 向 /info 端点提供信息","keywords":"","body":"15.3.1 向 /info 端点提供信息 正如您在第 15.2.1 节中所看到的，/info 端点开始时是空的，没有信息。但是，您可以通过创建以 info. 为前缀的属性，轻松地向里边添加数据。 为属性添加 info. 前缀，可以方便的将自定义数据添加到 /info 端点，但这并不是唯一的方法。Spring Boot 提供了一个名为 InfoContributor 的接口，允许您以代码方式，将任何信息添加到 /info 端点的响应数据中。Spring Boot 甚至已经提供了一些实现类，您会发现它们非常有用。 让我们看看如何编写自己的 InfoContributor，并向 /info 端点添加一些自定义信息。 创建自定义 Info Contributor 实现类 假设您想在 /info 端点中，添加一些有于 Taco Cloud 的简单统计信息。例如，有多少玉米卷已经制作出来了。为此，您可以编写一个实现 InfoContributor 接口的实现类，并注入 TacoRepository。然后就可以把 TacoRepository 能够提供的统计数据，提供给 /info 端点使用。以下的程序清单展示了如何实现这样的类。 程序清单 15.3 InfoContributor 的自定义实现类 package tacos.tacos; import org.springframework.boot.actuate.info.InfoContributor; import org.springframework.stereotype.Component; import java.util.HashMap; import java.util.Map; import org.springframework.boot.actuate.info.Info.Builder; @Component public class TacoCountInfoContributor implements InfoContributor { private TacoRepository tacoRepo; public TacoCountInfoContributor(TacoRepository tacoRepo) { this.tacoRepo = tacoRepo; } @Override public void contribute(Builder builder) { long tacoCount = tacoRepo.count(); Map tacoMap = new HashMap(); tacoMap.put(\"count\", tacoCount); builder.withDetail(\"taco-stats\", tacoMap); } } 实现 InfoContributor 接口时，TacoCountInfoContributor 需要实现 contribute()方法。此方法传入了一个 builder 对象，在该对象上调用 withDetail() 以添加详细信息。在上述实现中，通过调用 TacoRepository 的 count() 方法，查找已经制作了多少玉米卷。然后把这个数字放到一个 Map 对象中，最后将标签 taco-stats 提供给 Builder 对象。/info 端点的结果将包括该计数，如下所示： { \"taco-stats\": { \"count\": 44 } } 如您所见，InfoContributor 的实现类可以提供动态统计信息。这与简单地为属性加 info. 前缀形成对比，虽然简单，但仅限于静态值。 将构建信息注入 /INFO 端点 Spring Boot 附带了几个 InfoContributor 的内置实现，可以自动将信息添加到 /info 端点的结果数据中。其中包括 BuildInfoContributor，它将项目构建信息添加到 /info 端点。这包括项目版本、时间戳等基本信息，以及执行构建的主机和用户。 要使生成信息包含在 /info 端点的结果数据中，需要添加 build-info 到 Spring Boot Maven 插件执行目标中，如下所示： org.springframework.boot spring-boot-maven-plugin build-info 如果使用 Gradle 构建项目，只需将以下行添加到您的 build.gradle 文件： springBoot { buildInfo() } 在这两种情况下，构建都将在 JAR 或 WAR 文件中生成名为 build-info.properties 的文件，BuildInfoContributor 会把这些信息附加到 /info 端点返回数据中。以下代码片段显示了 /info 端点中的构建信息： { \"build\": { \"artifact\": \"tacocloud\", \"name\": \"taco-cloud\", \"time\": \"2021-08-08T23:55:16.379Z\", \"version\": \"0.0.15-SNAPSHOT\", \"group\": \"sia\" }, } 此信息有助于准确了解，正在运行的应用程序的版本、构建时间。通过对 /info 端点执行 GET 请求，您将知道您是否正在运行项目的最新版本。 公开 GIT 提交信息 假设您的项目使用 Git 进行源代码版本控制，您可能希望在 /info 端点中包括 Git 提交信息。要做到这一点，您需要在 Maven 项目 pom.xml 中添加以下插件： ... pl.project13.maven git-commit-id-plugin 如果您是 Gradle 用户，别担心，可以在 build.gradle 文件中添加一个同样功能的插件： plugins { id \"com.gorylenko.gradle-git-properties\" version \"2.2.4\" } 基本上这两个插件做的是相同的事情：它们生成一个构建产物 git.properties，包含项目的所有 git 元数据。专门的 InfoContributor 实现类在运行时扫描该文件，并将其内容作为 /info 端点返回数据的一部分。 最简单的形式，/info 端点中显示的 Git 信息包括，构建应用程序所依据的 Git 分支、提交哈希和时间戳： { \"git\": { \"branch\": \"main\", \"commit\": { \"id\": \"df45505\", \"time\": \"2021-08-08T21:51:12Z\" } }, ... } 此信息非常明确的描述项目启动时的代码状态。还可以将 management.info.git.mode 属性设置为 full，您就可以获得项目构建时有关 Git 提交的详细信息。 management: info: git: mode: full 下面的清单显示了完整 Git 的示例信息。 清单 15.4 通过 /info 端点公开的完整 Git 提交信息 \"git\":{ \"local\":{ \"branch\":{ \"ahead\":\"8\", \"behind\":\"0\" } }, \"commit\":{ \"id\":{ \"describe-short\":\"df45505-dirty\", \"abbrev\":\"df45505\", \"full\":\"df455055daaf3b1347b0ad1d9dca4ebbc6067810\", \"describe\":\"df45505-dirty\" }, \"message\":{ \"short\":\"Apply chapter 18 edits\", \"full\":\"Apply chapter 18 edits\" }, \"user\":{ \"name\":\"Craig Walls\", \"email\":\"craig@habuma.com\" }, \"author\":{ \"time\":\"2021-08-08T15:51:12-0600\" }, \"committer\":{ \"time\":\"2021-08-08T15:51:12-0600\" }, \"time\":\"2021-08-08T21:51:12Z\" }, \"branch\":\"master\", \"build\":{ \"time\":\"2021-08-09T00:13:37Z\", \"version\":\"0.0.15-SNAPSHOT\", \"host\":\"Craigs-MacBook-Pro.local\", \"user\":{ \"name\":\"Craig Walls\", \"email\":\"craig@habuma.com\" } }, \"tags\":\"\", \"total\":{ \"commit\":{ \"count\":\"196\" } }, \"closest\":{ \"tag\":{ \"commit\":{ \"count\":\"\" }, \"name\":\"\" } }, \"remote\":{ \"origin\":{ \"url\":\"git@github.com:habuma/spring-in-action-6-samples.git\" } }, \"dirty\":\"true\" }, 除了时间戳和 Git 提交哈希之外，完整版本还包括，提交代码的用户姓名和电子邮件，以及提交消息和其他信息。允许您精确地识别构建项目时使用的代码。事实上，请注意清单 15.4 中的 dirty 字段为 true，指出构建目录中有一些未提交的更改，这样的代码状态，真是没有什么情况比这更槽糕了！ "},"Chapter-15/15.3-Customizing-Actuator/15.3.2-Defining-custom-health-indicators.html":{"url":"Chapter-15/15.3-Customizing-Actuator/15.3.2-Defining-custom-health-indicators.html","title":"15.3.2 自定义健康指标","keywords":"","body":"15.3.2 自定义健康指标 对于一些常见的外部系统，与 Spring 应用程序集成时，Spring Boot 附带了几个现成的健康状况指示器，可提供它们的健康状况。但有时，您可能发现有一些外部系统，Spring Boot 并没有为其提供健康状况指示器。 例如，您的应用程序可能与遗留大型机应用程序集成，应用程序的健康状况，可能会受到遗留系统健康状况的影响。要创建自定义健康状况指示器，需创建一个实现 HealthIndicator 接口的类。 实际上，Taco Cloud 服务并不需要自定义健康指标，因为 Spring Boot 所提供的已经足够了。但为了展示如何开发自定义健康指示器，考虑以下程序清单，它展示了 HealthIndicator 的简单实现。其中选择一天中某个时间，随机地展示其健康状况。 程序清单 15.5 HealthIndicator 的非正常实现 package tacos.tacos; import java.util.Calendar; import org.springframework.boot.actuate.health.Health; import org.springframework.boot.actuate.health.HealthIndicator; import org.springframework.stereotype.Component; @Component public class WackoHealthIndicator implements HealthIndicator { @Override public Health health() { int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY); if (hour > 12) { return Health .outOfService() .withDetail(\"reason\", \"I'm out of service after lunchtime\") .withDetail(\"hour\", hour) .build(); } if (Math.random() 这个疯狂的健康指示器首先检查当前时间，如果是中午之后，返回 OUT_OF_SERVICE 的健康状况，并提供一些详细信息来解释故障原因。 即使是在午餐前，健康指标也有 10% 的可能性会报告 DOWN 的状态，因为它使用一个随机数来决定它是否正常运行。如果随机数字小于 0.1，状态将报告为 DOWN 。否则，状态为 UP。 显然，清单 15.5 中的健康状况指示器，在真实环境中任何情况下都不会有用。但是想象一下，如果代码中不是用随机数，而是远程调用某个外部系统并确定其状态。在这种情况下，这将是一个非常有用的健康状况指示器。 "},"Chapter-15/15.3-Customizing-Actuator/15.3.3-Registering-custom-metrics.html":{"url":"Chapter-15/15.3-Customizing-Actuator/15.3.3-Registering-custom-metrics.html","title":"15.3.3 注册自定义指标","keywords":"","body":"15.3.3 注册自定义指标 在第 15.2.4 节，我们介绍了如何发送 HTTP 请求，获取 /metrics 端点的数据，以使用 Actuator 发布的各种指标。Actuator 提供的指标非常有用，但是并不仅限于这些内置的度量指标。 其实，Actuator 指标由 Micrometer 实现 https://micrometer.io/。这是一种与供应商无关的度量，使应用程序能够发布任何想要的指标，并将其显示在第三方监控系统中。包括对 Prometheus、Datadog 和 New Relic 等的支持。 使用 Micrometer 发布度量的最基本方法是，使用 Micrometer 的 MeterRegistry。在 Spring Boot 应用程序中，当需要发布计数器、计时器或其他指标时，您只需发布指标到 MeterRegistry 中。 作为发布自定义度量的示例，假设您希望知道，有多少玉米卷用不同的配料制作出来了。就是，您想知道有多少玉米卷是用莴苣、牛肉或土豆或其他配料作成的。下面的清单显示了，TacoMetrics 是如何使用 MeterRegistry 收集这些信息的。 程序清单 15.6 TacoMetrics 注册有关玉米卷配料的指标 package tacos.tacos; import java.util.List; import org.springframework.data.rest.core.event.AbstractRepositoryEventListener; import org.springframework.stereotype.Component; import io.micrometer.core.instrument.MeterRegistry; @Component public class TacoMetrics extends AbstractRepositoryEventListener { private MeterRegistry meterRegistry; public TacoMetrics(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } @Override protected void onAfterCreate(Taco taco) { List ingredients = taco.getIngredients(); for (Ingredient ingredient : ingredients) { meterRegistry.counter(\"tacocloud\", \"ingredient\", ingredient.getId()).increment(); } } } 如您所见，TacoMetrics 通过其构造函数注入 MeterRegistry。它还扩展了 AbstractRepositoryEventListener，支持拦截存储库事件并重写了 onAfterCreate() 方法。这样就可以在保存新的 Taco 对象时随时获取事件通知。 在 onAfterCreate() 方法中，为每种配料声明一个计数器，名称为 ingredient ，标签值等于 ingredient 的 ID。如果计数器标记已存在，将重新使用，使计数值递增，这表示另一个玉米卷已经为这种配料添加过标识。 创建了几个 taco 之后，就可以开始查询 /metrics 端点了。对 /metrics/tacocloud 发关 GET 请求，会产生一些未过滤的度量计数： $ curl localhost:8087/actuator/metrics/tacocloud { \"name\": \"tacocloud\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 84 } ], \"availableTags\": [ { \"tag\": \"ingredient\", \"values\": [ \"FLTO\", \"CHED\", \"LETC\", \"GRBF\", \"COTO\", \"JACK\", \"TMTO\", \"SLSA\"] } ] } measurements 下的计数值在这里意义不大，因为它是计算所有配料的所有数据的总和。但假设您想知道有多少玉米卷由玉米面制成（FLTO），您需要做的就是指定成分值为 FLTO 的标记： $ curl localhost:8087/actuator/metrics/tacocloud?tag=ingredient:FLTO { \"name\": \"tacocloud\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 39 } ], \"availableTags\": [] } 现在很明显，39 个玉米卷的配料是玉米面。 "},"Chapter-15/15.3-Customizing-Actuator/15.3.4-Creating-custom-endpoints.html":{"url":"Chapter-15/15.3-Customizing-Actuator/15.3.4-Creating-custom-endpoints.html","title":"15.3.4 创建自定义端点","keywords":"","body":"15.3.4 创建自定义端点 乍一看，您可能认为 Actuator 的端点实现，和 Spring MVC 的 Controller 一样。正如您将在第 18 章中看到的，端点可以作为 JMX MBean，还可以通过 HTTP 访问。因此,对于这些端点来说，并不仅仅是 Controller 类。 事实上，Actuator 端点的定义与 Controller 完全不同。不同于用 @Controller 或 @RestController 注解的类，Actuator 端点使用带有 @Endpoint 注解的类定义。 更重要的是，不再使用 HTTP 命名注解，诸如 @GetMapping、@PostMapping 或 @DeleteMapping。Actuator 端点用 @ReadOperation、@WriteOperation 和 @DeleteOperation 注解。这些注解并不意味着任何特定的通信机制，事实上，允许 Actuator 通过各种通信机制进行通信，HTTP 和 JMX 开箱即用。 为了演示如何编写自定义 Actuator 端点，请参考如下的 NotesEndpoint。 程序清单 15.7 记录便笺的自定义端点 package tacos.ingredients; import java.util.ArrayList; import java.util.Date; import java.util.List; import org.springframework.boot.actuate.endpoint.annotation.DeleteOperation; import org.springframework.boot.actuate.endpoint.annotation.Endpoint; import org.springframework.boot.actuate.endpoint.annotation.ReadOperation; import org.springframework.boot.actuate.endpoint.annotation.WriteOperation; import org.springframework.stereotype.Component; import lombok.Getter; import lombok.RequiredArgsConstructor; @Component @Endpoint(id=\"notes\", enableByDefault=true) public class NotesEndpoint { private List notes = new ArrayList<>(); @ReadOperation public List notes() { return notes; } @WriteOperation public List addNote(String text) { notes.add(new Note(text)); return notes; } @DeleteOperation public List deleteNote(int index) { if (index 该端点是一个简单的便笺端点。在该端点中，用户可以使用写入操作增加一个便笺，使用读取操作读取便笺列表，然后使用删除操作删除便笺。诚然，这个端点对于 Actuator 来说不是很有用，但是当您考虑开箱即用的 Actuator 端点会涉及太多领域时，很难想出一个实用的自定义示例。 可以看到，NotesEndpoint 类合使用 @Component 注解，以便通过 Spring 的组件扫描获取，并在 Spring 中实例化为 bean。它还添加了注解 @Endpoint，使其成为 ID 为 notes 的 Actuator 端点。并且它是默认启用的，这样您就不需要通过将其包含在 management.web.endpoints.web.exposure.include 中来显式启用它。 如您所见，NotesEndpoint 提供了如下操作： notes() 方法用 @ReadOperation 注解。调用时，它将返回可用的便笺列表。使用 HTTP 时，这意味着它将处理对 /exactor/notes 的 HTTP GET 请求，并响应 JSON 形式的便笺列表。 addNote() 方法用 @WriteOperation 注解。当被调用时，它将根据给定文本创建新便笺，并将其添加到列表中。使用 HTTP 时，它处理 POST 请求，其中请求体是包含文本属性的 JSON 对象。处理完成后返回列表的当前状态。 deleteNote() 方法用 @DeleteOperation 注解。调用时，它将删除给定索引的便笺。使用 HTTP 时，该端点处理 DELETE 请求，在请求参数中给出便笺索引。 要查看实际运行效果，可以使用 curl 测试新端点。首先，添加几个便笺，使用两个单独的 POST 请求： $ curl localhost:8080/actuator/notes \\ -d'{\"text\":\"Bring home milk\"}' \\ -H\"Content-type: application/json\" [{\"time\":\"2020-06-08T13:50:45.085+0000\",\"text\":\"Bring home milk\"}] $ curl localhost:8080/actuator/notes \\ -d'{\"text\":\"Take dry cleaning\"}' \\ -H\"Content-type: application/json\" [{\"time\":\"2021-07-03T12:39:13.058+0000\",\"text\":\"Bring home milk\"}, {\"time\":\"2021-07-03T12:39:16.012+0000\",\"text\":\"Take dry cleaning\"}] 如您所见，每次发布新便笺时，端点都会返回最新便笺列表。如果以后要查看便笺列表，可以执行以下操作： $ curl localhost:8080/actuator/notes [{\"time\":\"2021-07-03T12:39:13.058+0000\",\"text\":\"Bring home milk\"}, {\"time\":\"2021-07-03T12:39:16.012+0000\",\"text\":\"Take dry cleaning\"}] ` 如果您决定删除其中一个便笺，则发送带有索引参数的 DELETE 请求： $ curl localhost:8080/actuator/notes?index=1 -X DELETE [{\"time\":\"2021-07-03T12:39:13.058+0000\",\"text\":\"Bring home milk\"}] 需要注意的是，尽管这里只演示了使用 HTTP 如何与端点交互，但它还作为 MBean 公开了，可以使用任何您熟悉的 JMX 客户端进行访问。如果您想将其限制为仅公开 HTTP 端点，您可以使用 @WebEndpoint 而不是 @endpoint 注解端点类： @Component @WebEndpoint(id=\"notes\", enableByDefault=true) public class NotesEndpoint { ... } 同样，如果您喜欢只使用 MBean 的端点，请使用 @JmxEndpoint 注解。 "},"Chapter-15/15.4-Securing-Actuator.html":{"url":"Chapter-15/15.4-Securing-Actuator.html","title":"15.4 保护 Actuator","keywords":"","body":"15.4 保护 Actuator 对于 Actuator 提供的信息，可能您并不想被间谍窥探到。此外，由于 Actuator 提供了可以更改环境属性，以及调整日志记录级别的操作，那么使只允许具有适当访问权限的客户，才能使用 Actuator 是必要的。 尽管确保 Actuator 的安全非常重要，但 Actuator 并没有提供安全措施的责任。相反，您需要使用 Spring Security 来保护 Actuator。因为 Actuator 端点只是应用程序中的路径，这与应用程序中的任何其他路径没什么区别，所以确保 Actuator 的安全措施，与保证应用程序其他路径的安全措施相比，没有什么独特之处。我们在第 4 章中讨论的所有内容都适用 Actuator 端点。 因为所有的 Actuator 端点都集中在路径 /actuator 下（或者其他路径，如果设置了 management.endpoints.web.base-path 属性），很容易将授权规则应用于 Actuator 端点。例如，要求用户具有要 ROLE_ADMIN 权限，以调用 Actuator 端点，您可以重写 WebSecurityConfigurerAdapter 的 configure() 方法，如下所示： @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\"/actuator/**\").hasRole(\"ADMIN\") .and() .httpBasic(); } 这要求，所有请求都要来自具有 ROLE_ADMIN 权限的用户。另外还配置了 HTTP 基本身份验证，以便客户端应用程序，可以在请求头 Authorization 属性中，传输编码过的身份验证信息。 以这种方式保护 Actuator 的真正问题是，端点的路径硬编码为 /actuator/** 了。如果修改了 management.endpoints.web.base-path 属性，它将不再工作。为解决这个问题，Spring Boot 还提供了 EndpointRequest，这是一个请求匹配器类。它更容易使用，而且不依赖于给定的字符串路径。使用 EndpointRequest，您可以对 Actuator 端点应用相同的安全配置，而无需硬编码 /actuator/** 路径： @Override protected void configure(HttpSecurity http) throws Exception { http .requestMatcher(EndpointRequest.toAnyEndpoint()) .authorizeRequests() .anyRequest().hasRole(\"ADMIN\") .and() .httpBasic(); } EndpointRequest.toAnyEndpoint() 方法返回一个请求匹配器，该匹配器匹配任何 Actuator 端点。如果要从中排除某些端点，可以调用 excluding()，并按名称指定它们： @Override protected void configure(HttpSecurity http) throws Exception { http .requestMatcher(EndpointRequest.toAnyEndpoint().excluding(\"health\", \"info\")) .authorizeRequests() .anyRequest().hasRole(\"ADMIN\") .and() .httpBasic(); } 另一方面，您如果希望对少数 Actuator 进行保护，您可以通过调用 to() 方法，而不是 toAnyEndpoint() 方法： @Override protected void configure(HttpSecurity http) throws Exception { http .requestMatcher(EndpointRequest.to(\"beans\", \"threaddump\", \"loggers\")) .authorizeRequests() .anyRequest().hasRole(\"ADMIN\") .and() .httpBasic(); } 这将 Actuator 的安全性仅限于 /bean、/threaddump 和 /loggers 端点。所有其他 Actuator 端点完全开放。 "},"Chapter-15/15.5-Summary.html":{"url":"Chapter-15/15.5-Summary.html","title":"15.5 总结","keywords":"","body":"15.5 总结 Spring Boot Actuator 提供了几个端点，可做为 HTTP 和 JMX MBean，让您可以窥探 Spring Boot 应用程序的内部工作情况。 默认情况下，大多数 Actuator 端点处于禁用状态，但可以有选择地通过设置 management.endpoints.web.exposure.include 和 management.endpoints.web.exposure.exclude 调整停启用状态。 某些端点（如 /logger 和 /env 端点）允许写操作，动态更改正在运行的应用程序的配置。 有关应用程序的构建和 Git 提交的详细信息，可以通过 /info 端点获取。 应用程序的运行状况，可能会受到自定义运行状况指示器的影响，运行状况来自于外部集成应用程序的运行状况。 自定义应用程序度量指标，可以通过 Micrometer 注册。Micrometer 支撑了 Spring Boot 应用程序与几个流行指标引擎集成，包括 Datadog、New Relic 和 Prometheus 等。 Actuator web 端点可以使用 Spring Security 进行保护，就像保护任何 Spring Web 应用程序中的其他端点那样。 "},"Chapter-16/Introduction.html":{"url":"Chapter-16/Introduction.html","title":"第 16 章 管理 Spring","keywords":"","body":"第 16 章 管理 Spring "},"Chapter-16/16.1-Using-Spring-Boot-Admin/Introduction.html":{"url":"Chapter-16/16.1-Using-Spring-Boot-Admin/Introduction.html","title":"16.1 使用 SpringBoot Admin","keywords":"","body":"16.1 使用 SpringBoot Admin "},"Chapter-16/16.1-Using-Spring-Boot-Admin/16.1.1-Creating-an-Admin-server.html":{"url":"Chapter-16/16.1-Using-Spring-Boot-Admin/16.1.1-Creating-an-Admin-server.html","title":"16.1.1 创建 Admin 服务端","keywords":"","body":"16.1.1 创建 Admin 服务端 "},"Chapter-16/16.1-Using-Spring-Boot-Admin/16.1.2-Registering-Admin-clients.html":{"url":"Chapter-16/16.1-Using-Spring-Boot-Admin/16.1.2-Registering-Admin-clients.html","title":"16.1.2 注册 Admin 客户端","keywords":"","body":"16.1.2 注册 Admin 客户端 "},"Chapter-16/16.2-Exploring-the-Admin-server/Introduction.html":{"url":"Chapter-16/16.2-Exploring-the-Admin-server/Introduction.html","title":"16.2 深入 Admin 服务端","keywords":"","body":"16.2 深入 Admin 服务端 "},"Chapter-16/16.2-Exploring-the-Admin-server/16.2.1-Viewing-general-application-health-and-information.html":{"url":"Chapter-16/16.2-Exploring-the-Admin-server/16.2.1-Viewing-general-application-health-and-information.html","title":"16.2.1 查看普通应用程序运行状况和信息","keywords":"","body":"16.2.1 查看普通应用程序运行状况和信息 "},"Chapter-16/16.2-Exploring-the-Admin-server/16.2.2-Watching-key-metrics.html":{"url":"Chapter-16/16.2-Exploring-the-Admin-server/16.2.2-Watching-key-metrics.html","title":"16.2.2 观察关键指标","keywords":"","body":"16.2.2 观察关键指标 "},"Chapter-16/16.2-Exploring-the-Admin-server/16.2.3-Examining-environment-properties.html":{"url":"Chapter-16/16.2-Exploring-the-Admin-server/16.2.3-Examining-environment-properties.html","title":"16.2.3 检查环境属性","keywords":"","body":"16.2.3 检查环境属性 "},"Chapter-16/16.2-Exploring-the-Admin-server/16.2.4-Viewing-and-setting-logging-levels.html":{"url":"Chapter-16/16.2-Exploring-the-Admin-server/16.2.4-Viewing-and-setting-logging-levels.html","title":"16.2.4 查看并设置 log 级别","keywords":"","body":"16.2.4 查看并设置 log 级别 "},"Chapter-16/16.3-Securing-the-Admin-server/Introduction.html":{"url":"Chapter-16/16.3-Securing-the-Admin-server/Introduction.html","title":"16.3 保护 Admin 服务端","keywords":"","body":"16.3 保护 Admin 服务端 "},"Chapter-16/16.3-Securing-the-Admin-server/16.3.1-Enabling-login-in-the-Admin-server.html":{"url":"Chapter-16/16.3-Securing-the-Admin-server/16.3.1-Enabling-login-in-the-Admin-server.html","title":"16.3.1 在 Admin 服务端中启用登录","keywords":"","body":"16.3.1 在 Admin 服务端中启用登录 "},"Chapter-16/16.3-Securing-the-Admin-server/16.3.2-Authenticating-with-the-Actuator.html":{"url":"Chapter-16/16.3-Securing-the-Admin-server/16.3.2-Authenticating-with-the-Actuator.html","title":"16.3.2 使用 Actuator 进行认证","keywords":"","body":"16.3.2 使用 Actuator 进行认证 "},"Chapter-16/16.4-Summary.html":{"url":"Chapter-16/16.4-Summary.html","title":"16.4 总结","keywords":"","body":"16.4 总结 "},"Chapter-17/Introduction.html":{"url":"Chapter-17/Introduction.html","title":"第 17 章 使用 JMX 监控 Spring","keywords":"","body":"第 17 章 使用 JMX 监控 Spring "},"Chapter-17/17.1-Working-with-Actuator-MBeans.html":{"url":"Chapter-17/17.1-Working-with-Actuator-MBeans.html","title":"17.1 使用 Actuator MBean","keywords":"","body":"17.1 使用 Actuator MBean "},"Chapter-17/17.2-Creating-your-own-MBeans.html":{"url":"Chapter-17/17.2-Creating-your-own-MBeans.html","title":"17.2 创建自己的 MBean","keywords":"","body":"17.2 创建自己的 MBean "},"Chapter-17/17.3-Sending-notifications.html":{"url":"Chapter-17/17.3-Sending-notifications.html","title":"17.3 发送通知","keywords":"","body":"17.3 发送通知 "},"Chapter-17/17.4-Summary.html":{"url":"Chapter-17/17.4-Summary.html","title":"17.4 总结","keywords":"","body":"17.4 总结 "},"Chapter-18/Introduction.html":{"url":"Chapter-18/Introduction.html","title":"第 18 章 部署 Spring","keywords":"","body":"第 18 章 部署 Spring "},"Chapter-18/18.1-Weighing-deployment-options.html":{"url":"Chapter-18/18.1-Weighing-deployment-options.html","title":"18.1 权衡部署选项","keywords":"","body":"18.1 权衡部署选项 "},"Chapter-18/18.2-Building-executable-JAR-files.html":{"url":"Chapter-18/18.2-Building-executable-JAR-files.html","title":"18.2 构建可执行 JAR 文件","keywords":"","body":"18.2 构建可执行 JAR 文件 "},"Chapter-18/18.3-Building-container-images/Introduction.html":{"url":"Chapter-18/18.3-Building-container-images/Introduction.html","title":"18.3 构建容器镜像","keywords":"","body":"18.3 构建容器镜像 "},"Chapter-18/18.3-Building-container-images/18.3.1-Deploying-to-Kubernetes.html":{"url":"Chapter-18/18.3-Building-container-images/18.3.1-Deploying-to-Kubernetes.html","title":"18.3.1 部署到 Kubernetes","keywords":"","body":"18.3.1 部署到 Kubernetes "},"Chapter-18/18.3-Building-container-images/18.3.2-Enabling-graceful-shutdown.html":{"url":"Chapter-18/18.3-Building-container-images/18.3.2-Enabling-graceful-shutdown.html","title":"18.3.2 启用优雅关闭","keywords":"","body":"18.3.2 启用优雅关闭 "},"Chapter-18/18.3-Building-container-images/18.3.3-Working-with-application-liveness-and-readiness.html":{"url":"Chapter-18/18.3-Building-container-images/18.3.3-Working-with-application-liveness-and-readiness.html","title":"18.3.3 应用存活性和可用性","keywords":"","body":"18.3.3 应用存活性和可用性 "},"Chapter-18/18.4-Building-and-deploying-WAR-files.html":{"url":"Chapter-18/18.4-Building-and-deploying-WAR-files.html","title":"18.4 构建并部署 WAR 文件","keywords":"","body":"18.4 构建并部署 WAR 文件 "},"Chapter-18/18.5-The-end-is-where-we-begin.html":{"url":"Chapter-18/18.5-The-end-is-where-we-begin.html","title":"18.5 终章","keywords":"","body":"18.5 终章 "},"Chapter-18/18.6-Summary.html":{"url":"Chapter-18/18.6-Summary.html","title":"18.6 总结","keywords":"","body":"18.6 总结 "}}